---
title: ES 2023 Immutable Arrays
coverImage: /covers/linux-windows-mac.webp
status: 'draft'
publishedAt: 2023-11-30
brief: Working with toSpliced, toSorted, & toReversed
tags:
  - JavaScript
  - JS
	- EcmaScript
	- ES2023
	- ES14
	- Arrays
---

# ES2023 Immutable Array Methods

Archive: No
Area/Resource: Blog Drafts (https://www.notion.so/Blog-Drafts-d1b7b1bff49b4d6fae70537b0e2752c2?pvs=21)

If youâ€™re anything like me it was easy to miss some small, but powerful features that were introduced to ES14 a few months before the time of this writing. For example, `Array.prototype` just got way better in some subtle ways.

## The 4 New Array Methods âœ¨

```tsx
Array.prototype.toSpliced()
Array.prototype.toSorted()
Array.prototype.toReversed()
Array.prototype.with()
```

With the exception of `with()` all of these methods provide the same functionality youâ€™re used to when working with `splice` , `sort` , and `reverse` . However, the big change here has to do with array mutations. These old school methods act like stateful object oriented methods, where they mutate the state of the array instance they are called on. On the other hand, these new array methods behave as `Functors` and only execute the mutation on a brand new copy of the array, and return the new copied result, rather than mutating the array in place _(and in the case of `splice` returning the removed result while also mutating the array)_.

## Mutable Example

This is pretty useful when working with method chaining. Letâ€™s take the following [Code Wars Kata](https://www.codewars.com/kata/576b93db1129fcf2200001e6/solutions/typescript?filter=all&sort=best_practice&invalids=false):

> Sum all the numbers of a given array, except the highest and the lowest element (by value, not by index)

So first we need to sort the array, then remove the first and last elements, then return the sum. Classically in JavaScript this could look something like this:

```jsx
export function sumArray(array) {
  const sortedArray = array.sort((a, b) => a - b)

  sortedArray.shift()
  sortedArray.pop()

  return sortedArray.reduce((a, b) => a + b, 0)
}
```

## Problems with Classic Array Methods

The code above feels a little stiff and uncomfortable for me the more I look at it. There are a few problems that stand out:

### Sort Mutation

**1. Sort mutations kinda suck**. But theyâ€™re the best weâ€™ve had for a long time unless you reach for `lodash` or `ramda` which offer immutable sort functions. Letâ€™s take a look at the first line of our function body:

```jsx
const sortedArray = array.sort((a, b) => a - b)
```

While the `sort` method returns the new sorted array, it also **_mutated the parameter that was passed in_**. This is now a side effect we have to keep track of. To remove this side-effect and make our function pure, historically we would do something like use the spread operator to copy the array inside our function body before sorting:

```jsx
const sortedArray = [...array].sort((a, b) => a - b)
```

But with the new `toSorted` method the following works just the same, and we donâ€™t need to use the spread operator at all:

```jsx
const sortedArray = array.toSorted((a, b) => a - b)
```

### Element Removal Mutation

The other portion of the function that has my eyes watery is the `shift` and `pop` pieces up above. If we hadnâ€™t just refactored our sort functionality, we would have removed items from the original array and now would have no way to reset back to our original state. That old array is gone forever, so we better hope no other part of the codebase relied on it for other computations. This isnâ€™t as big of a problem now that weâ€™re mutating the **_copied_** parameter via `toSorted.` . But even still, we can improve this code with `toSpliced`. In the classic JavaScript we could refactor our `shift` and `pop` code using `splice` and it would look something like this:

```jsx
sortedArray.splice(0, 1)
sortedArray.splice(-1, 1)
```

But since we now have `toSpliced` which returns a copied array with the result of the splice operation, weâ€™ve got some huge wins.

1. Weâ€™ve prevented accidental deletion of array elements no matter what, without needing to depend on the previous line containing `toSorted`
2. We can take our entire function body a step further with some sweet functional chaining. Since all of these methods are functors weâ€™ve unlocked our [Referential Transparency](https://www.sitepoint.com/what-is-referential-transparency/) badge.

The final ES2024 version of the code is massively simplified and far safer, all while using convenient function chaining:

```jsx
export function sumArray(array) {
  return
  array
    .toSorted((a, b) => a - b)
    .toSpliced(0, 1)
    .toSpliced(-1, 1)
    .reduce((a, b) => a + b, 0)
}
```

Woot woot ğŸ‘ğŸ»ğŸ‘ğŸ»ğŸ‘ğŸ»

## With()

Youâ€™ll notice I didnâ€™t talk about `with` at all. Feel free to check out the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/with) if youâ€™re curious, but I plan to do an entirely different blog post on the with method, because the implications are pretty cool.

## Immutability: Cost to Performance

As with most things in life, these new tools involve us measuring trade-offs. Technically speaking these new methods are more expensive than the older methods. Since physics is still physics, and there arenâ€™t any breakthroughs in science that have shattered my perceptions of how computation works, _yes copying all the bits is always more expensive than adding or removing specific bits to a known part of the heap_.

So the main drawbacks are:

- Garbage collection will take longer.
- You are holding more data in memory at specific points in time.

Mutations are still useful when:

- You are working with incredibly large lists.
- Working to reduce your O^n for a given part of your codebase.
- You can limit & carefully place your application side effects inside just a handful of cautious & well tested functions.
- At the beginning of any unit of work you have a `reset` function that can help you bounce back to your initial state for debugging or computation that needs to happen elsewhere.

For me I always lean towards maximizing safety and readability through immutability day in and day out. Iâ€™m not a game developer managing pointers, and modern garbage collectors are really, really good. This is the natural progression of the JavaScript language over time as new methods have given the vanilla language feature parody with some of the open source libraries weâ€™ve needed to pull in in the past. So until copying lists proves to be a problem in a particular codebase, ill always optimize for readability first. I may switch up my approach and need to be more cautious as cases arises naturally. But for most of us, these new methods solve more customer bugs caused by bad mutations, with manageable trade-offs when applied wisely.

Cheers! ğŸ¤™
